/*
 * Kevin DeWire
 * CS 723 Bioinformatics
 * Reduced Representation of a Protein Structure
 */
package bioinfoproject;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import static java.lang.Math.atan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;

class MyCustomFilter extends javax.swing.filechooser.FileFilter {
    @Override
    public boolean accept(File file) {
        // Allow only directories, or files with ".txt" extension
        return file.isDirectory() || file.getAbsolutePath().endsWith(".txt") || file.getAbsolutePath().endsWith(".pdb") || file.getAbsolutePath().endsWith(".PDB");
    }
    @Override
    public String getDescription() {
        // This description will be displayed in the dialog,
        // hard-coded = ugly, should be done via I18N
        return "Text documents (*.txt) or PDB files (*.pdb)";
    }
}

public class Interface extends javax.swing.JFrame {

    /**
     * Creates new form Interface
     */
    public Interface() {
        initComponents();
        AlignHelices.setEnabled(false);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        FileChooser = new javax.swing.JFileChooser();
        jScrollPane1 = new javax.swing.JScrollPane();
        InputTextArea = new javax.swing.JTextArea();
        caExtract = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        OutputTextArea = new javax.swing.JTextArea();
        bSheetCenter = new javax.swing.JButton();
        HelixCenter = new javax.swing.JButton();
        InputLabel = new javax.swing.JLabel();
        OutputLabel = new javax.swing.JLabel();
        Helix1 = new javax.swing.JButton();
        Helix2 = new javax.swing.JButton();
        AlignHelices = new javax.swing.JButton();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        Open = new javax.swing.JMenuItem();
        Exit = new javax.swing.JMenuItem();

        FileChooser.setDialogTitle("");
        FileChooser.setFileFilter(new MyCustomFilter());

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        InputTextArea.setEditable(false);
        InputTextArea.setColumns(40);
        InputTextArea.setRows(5);
        jScrollPane1.setViewportView(InputTextArea);

        caExtract.setText("Extract CA Atoms");
        caExtract.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                caExtractActionPerformed(evt);
            }
        });

        OutputTextArea.setEditable(false);
        OutputTextArea.setColumns(40);
        OutputTextArea.setRows(5);
        jScrollPane2.setViewportView(OutputTextArea);

        bSheetCenter.setText("Extract B-Sheet");
        bSheetCenter.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bSheetCenterActionPerformed(evt);
            }
        });

        HelixCenter.setText("Extract Helix");
        HelixCenter.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                HelixCenterActionPerformed(evt);
            }
        });

        InputLabel.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        InputLabel.setText("Input File");

        OutputLabel.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        OutputLabel.setText("Output File");

        Helix1.setText("Input 1");
        Helix1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Helix1ActionPerformed(evt);
            }
        });

        Helix2.setText("Input 2");
        Helix2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Helix2ActionPerformed(evt);
            }
        });

        AlignHelices.setText("Align Helices");
        AlignHelices.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AlignHelicesActionPerformed(evt);
            }
        });

        jMenu1.setText("File");

        Open.setText("Open");
        Open.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                OpenActionPerformed(evt);
            }
        });
        jMenu1.add(Open);

        Exit.setText("Exit");
        Exit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ExitActionPerformed(evt);
            }
        });
        jMenu1.add(Exit);

        jMenuBar1.add(jMenu1);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(InputLabel))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(caExtract, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(HelixCenter, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(Helix2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(Helix1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(AlignHelices, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addComponent(bSheetCenter, javax.swing.GroupLayout.PREFERRED_SIZE, 117, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(18, 18, Short.MAX_VALUE)
                        .addComponent(OutputLabel)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(InputLabel)
                    .addComponent(OutputLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(caExtract, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(HelixCenter, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(bSheetCenter, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 60, Short.MAX_VALUE)
                        .addComponent(Helix1)
                        .addGap(18, 18, 18)
                        .addComponent(Helix2)
                        .addGap(18, 18, 18)
                        .addComponent(AlignHelices, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jScrollPane1)
                    .addComponent(jScrollPane2))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void OpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_OpenActionPerformed
        // This Section allows the user to pick the input file.
        int returnVal = FileChooser.showOpenDialog(this);
            if (returnVal == FileChooser.APPROVE_OPTION) {
                InputLabel.setText("Input File");
                OutputLabel.setText("Output File");
                OutputTextArea.setText("");
                AlignHelices.setEnabled(false);
                File InputFile = FileChooser.getSelectedFile();
                try {
                  // What to do with the file, e.g. display it in a TextArea
                  InputTextArea.read( new FileReader( InputFile.getAbsolutePath() ), null );
                } catch (IOException ex) {
                  System.
                          out.println("problem accessing file"+InputFile.getAbsolutePath());
                }
                Input = InputTextArea.getText().split("\n");
            } else {
                System.out.println("File access cancelled by user.");
            }
    }//GEN-LAST:event_OpenActionPerformed

    private void ExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ExitActionPerformed
        System.exit(0);
    }//GEN-LAST:event_ExitActionPerformed

    private void caExtractActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_caExtractActionPerformed
        // This section allows the user to set the file that the CA extraction will be saved.
        BufferedWriter writer;
        int returnVal = FileChooser.showSaveDialog(this);
            if (returnVal == FileChooser.APPROVE_OPTION) {
                File OutputFile = FileChooser.getSelectedFile();                
                DisableButtons();
                OutputTextArea.setText("");
                caExtraction();
                try {
                  writer = new BufferedWriter( new FileWriter( OutputFile.getAbsolutePath(), false ));
                  OutputTextArea.write( writer );
                  writer.close();
                } catch (IOException ex) {
                  System.
                          out.println("problem accessing file"+OutputFile.getAbsolutePath());
                }
            } else {
                System.out.println("File access cancelled by user.");
            }
        EnableButtons();
    }//GEN-LAST:event_caExtractActionPerformed

    private void bSheetCenterActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bSheetCenterActionPerformed
        // This secion allows the user to set the file that the B-Sheet Centerline will be saved
        BufferedWriter writer;
        int returnVal = FileChooser.showSaveDialog(this);
            if (returnVal == FileChooser.APPROVE_OPTION) {
                File OutputFile = FileChooser.getSelectedFile();                
                DisableButtons();
                OutputTextArea.setText("");
                bSheetExtraction();
                try {
                  writer = new BufferedWriter( new FileWriter( OutputFile.getAbsolutePath(), false ));
                  OutputTextArea.write( writer );
                  writer.close();
                } catch (IOException ex) {
                  System.
                          out.println("problem accessing file"+OutputFile.getAbsolutePath());
                }
            } else {
                System.out.println("File access cancelled by user.");
            }
        EnableButtons();
    }//GEN-LAST:event_bSheetCenterActionPerformed

    private void HelixCenterActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_HelixCenterActionPerformed
        // This secion allows the user to set the file that the Helix Centerline will be saved
        BufferedWriter writer;
        int returnVal = FileChooser.showSaveDialog(this);
            if (returnVal == FileChooser.APPROVE_OPTION) {
                File OutputFile = FileChooser.getSelectedFile();                
                DisableButtons();
                OutputTextArea.setText("");
                HelixExtraction();
                try {
                  writer = new BufferedWriter( new FileWriter( OutputFile.getAbsolutePath(), false ));
                  OutputTextArea.write( writer );
                  writer.close();
                } catch (IOException ex) {
                  System.
                          out.println("problem accessing file"+OutputFile.getAbsolutePath());
                }
            } else {
                System.out.println("File access cancelled by user.");
            }
        EnableButtons();
    }//GEN-LAST:event_HelixCenterActionPerformed

    private void AlignHelicesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AlignHelicesActionPerformed
        // This secion allows the user to set the file that the Helix 2 Alignment will be saved
        BufferedWriter writer;
        int returnVal = FileChooser.showSaveDialog(this);
            if (returnVal == FileChooser.APPROVE_OPTION) {
                File OutputFile = FileChooser.getSelectedFile();                
                DisableButtons();
                HelixAlignment();
                try {
                  writer = new BufferedWriter( new FileWriter( OutputFile.getAbsolutePath(), false ));
                  OutputTextArea.write( writer );
                  writer.close();
                } catch (IOException ex) {
                  System.
                          out.println("problem accessing file"+OutputFile.getAbsolutePath());
                }
            } else {
                System.out.println("File access cancelled by user.");
            }
        EnableButtons();
    }//GEN-LAST:event_AlignHelicesActionPerformed

    private void Helix1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Helix1ActionPerformed
        // This Section allows the user to pick the Helix 1 file.
        int returnVal = FileChooser.showOpenDialog(this);
            if (returnVal == FileChooser.APPROVE_OPTION) {
                InputLabel.setText("Helix 1");                
                File InputFile = FileChooser.getSelectedFile();
                try {
                  // What to do with the file, e.g. display it in a TextArea
                  InputTextArea.read( new FileReader( InputFile.getAbsolutePath() ), null );
                } catch (IOException ex) {
                  System.
                          out.println("problem accessing file"+InputFile.getAbsolutePath());
                }
                Input = null;
                Input = InputTextArea.getText().split("\n");
            } else {
                System.out.println("File access cancelled by user.");
            }
    }//GEN-LAST:event_Helix1ActionPerformed

    private void Helix2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Helix2ActionPerformed
        // This Section allows the user to pick the Helix 2 file.
        int returnVal = FileChooser.showOpenDialog(this);
            if (returnVal == FileChooser.APPROVE_OPTION) {                
                OutputLabel.setText("Helix 2");
                AlignHelices.setEnabled(true);
                File InputFile = FileChooser.getSelectedFile();
                try {
                  // What to do with the file, e.g. display it in a TextArea
                  OutputTextArea.read( new FileReader( InputFile.getAbsolutePath() ), null );
                } catch (IOException ex) {
                  System.
                          out.println("problem accessing file"+InputFile.getAbsolutePath());
                }
                Input2 = null;
                Input2 = OutputTextArea.getText().split("\n");
            } else {
                System.out.println("File access cancelled by user.");
            }
    }//GEN-LAST:event_Helix2ActionPerformed

    private void DisableButtons(){
        caExtract.setEnabled(false);
        HelixCenter.setEnabled(false);
        bSheetCenter.setEnabled(false);
        Helix1.setEnabled(false);
        Helix2.setEnabled(false);        
    }
    
    private void EnableButtons(){
        caExtract.setEnabled(true);
        HelixCenter.setEnabled(true);
        bSheetCenter.setEnabled(true);
        Helix1.setEnabled(true);
        Helix2.setEnabled(true);
    }
    
    private void caExtraction(){
        for (int i=0; i<Input.length-1; i++){
            if ("ATOM  ".equals(RecordType(Input[i])) && " CA ".equals(AtomName(Input[i])) && "A".equals(ChainID(Input[i]))){               
                OutputTextArea.append(Input[i] + "\n");
            }
        }
        OutputTextArea.append("END   " + "\n");
    }
    
    private void HelixExtraction(){
        for (int i=0; i<Input.length-1; i++){
            if ("HELIX ".equals(RecordType(Input[i]))){
                String helixChainID = HelixChainID(Input[i]);              
                int initSeqNum = HelixInitSeqNum(Input[i]);                
                int endSeqNum = HelixEndSeqNum(Input[i]);
                HelixCenter(helixChainID, initSeqNum, endSeqNum);
            }
        }
        OutputTextArea.append("END   " + "\n");
    }
    
    private void HelixCenter(String helixChainID, int initSeqNum, int endSeqNum){
        int j = 0;      // Used to track when average calculation takes place
        int k = 0;      // Tracks which record is currently being used
        double x;
        double y;
        double z;
        String chainID;
        int resSeq;
        int numRec = 4; // This can be changed to increase or decrease the number of records used in calculation.
        String[] record;
        record = new String [numRec];
        
        for (int i=0; i<Input.length-1; i++){
            if ("ATOM  ".equals(RecordType(Input[i]))){
                chainID = ChainID(Input[i]);
                if (chainID.equals(helixChainID)){
                    resSeq = ResSeq(Input[i]);
                    // This section handles all Helices equal to or longer than numRec number of residues.
                    if (resSeq >= initSeqNum && resSeq <= endSeqNum){
                        if (" CA ".equals(AtomName(Input[i]))){
                            record[k] = Input[i];
                            j++;
                            k++;
                            if (j == numRec){
                                x = AvgX(record, numRec);
                                y = AvgY(record, numRec);
                                z = AvgZ(record, numRec);
                                Output(record[k-1], x, y, z);
                                j = j-1;
                                if (k == numRec || resSeq == endSeqNum){
                                    k = 0;
                                }
                            }
                        }
                    }
                    // This section handles all Helices shorter than the numRec number of residues.
                    if (resSeq > endSeqNum){
                        if (k > 0){
                            x = AvgX(record, k);
                            y = AvgY(record, k);
                            z = AvgZ(record, k);
                            Output(record[k-1], x, y, z);
                        }
                        break;
                    } 
                }

            }
        }
        OutputTextArea.append("TER   " + "\n");
    }
    
    private void bSheetExtraction(){
        for (int i=0; i<Input.length-1; i++){
            if ("SHEET ".equals(RecordType(Input[i]))){
                String bSheetChainID = SheetChainID(Input[i]);
                int initSeqNum = SheetInitSeqNum(Input[i]);
                int endSeqNum = SheetEndSeqNum(Input[i]);
                bSheetCenter(bSheetChainID, initSeqNum, endSeqNum);
            }
        }
        OutputTextArea.append("END   " + "\n");
    }
    
    private void bSheetCenter(String bSheetChainID, int initSeqNum, int endSeqNum){
        int j = 0;      // Used to track when average calculation takes place
        int k = 0;      // Tracks which record is currently being used
        double x;
        double y;
        double z;
        String chainID;
        int resSeq;
        int numRec = 4; // This can be changed to increase or decrease the number of records used in calculation.
        String[] record;
        record = new String [numRec];
        
        for (int i=0; i<Input.length-1; i++){
            if ("ATOM  ".equals(RecordType(Input[i]))){
                chainID = ChainID(Input[i]);
                if (chainID.equals(bSheetChainID)){
                    resSeq = ResSeq(Input[i]);
                    // This section handles all b Sheets equal to or longer than numRec number of atoms.
                    if (resSeq >= initSeqNum && resSeq <= endSeqNum){
                        if (" N  ".equals(AtomName(Input[i])) || " CA ".equals(AtomName(Input[i])) || " C  ".equals(AtomName(Input[i]))){
                            record[k] = Input[i];
                            j++;
                            k++;
                            if (j == numRec){
                                x = AvgX(record, numRec);
                                y = AvgY(record, numRec);
                                z = AvgZ(record, numRec);
                                Output(record[k-1], x, y, z);
                                j = j-1;
                                if (k == numRec || resSeq == endSeqNum){
                                    k = 0;
                                }
                            }
                        }
                    }
                    // This section handles all b Sheets shorter than the numRec number of atoms.  Probably will not be used.
                    if (resSeq > endSeqNum){
                        if (k > 0){
                            x = AvgX(record, k);
                            y = AvgY(record, k);
                            z = AvgZ(record, k);
                            Output(record[k-1], x, y, z);
                        }
                        break;
                    } 
                }

            }
        }
        OutputTextArea.append("TER   " + "\n");
    }
    
    // This controls the process of moving and rotating the second helix.
    private void HelixAlignment(){
        double[][] helixPoints1;                    // x, y, z coords for each residue CA
        double[][] helixPoints2;                    // x, y, z coords for each residue CA
        double[] helixMidPoint1 = new double[3];    // x, y, z coords
        double[] helixMidPoint2 = new double[3];    // x, y, z coords
        double[] helixEndPoint1 = new double[3];    // x, y, z coords
        double[] helixEndPoint2 = new double[3];    // x, y, z coords
        double[] helixMoveDist = new double[3];
        double thetaX, thetaY, thetaZ;
        // Get coords for points in helix 1, will only use the first helix in the file.
        helixPoints1 = HelixSetup(Input);
        // Get coords for points in helix 2, will only use the first helix in the file.
        helixPoints2 = HelixSetup(Input2);
        // Find midpoint of each helix and move helix 2 to match helix 1.
        HelixMidPoint(helixPoints1, helixMidPoint1);
        HelixMidPoint(helixPoints2, helixMidPoint2);
        MoveDistance(helixMidPoint1, helixMidPoint2, helixMoveDist);
        MoveInput(Input2, helixMoveDist);
        helixPoints2 = HelixSetup(Input2);
        // Find the endpoints and then progressivly rotate helix 2 around z, y, x axis.
        HelixEndPoint(helixPoints1, helixEndPoint1);
        HelixEndPoint(helixPoints2, helixEndPoint2);
        thetaZ = Theta(helixEndPoint1, helixMidPoint1, 1, 0) - Theta(helixEndPoint2, helixMidPoint1, 1, 0);
        RotateZ(Input2, helixMidPoint1, thetaZ);
        helixPoints2 = HelixSetup(Input2);
        HelixEndPoint(helixPoints2, helixEndPoint2);
        thetaY = Theta(helixEndPoint1, helixMidPoint1, 2, 0) - Theta(helixEndPoint2, helixMidPoint1, 2, 0);
        RotateY(Input2, helixMidPoint1, thetaY);
        helixPoints2 = HelixSetup(Input2);
        HelixEndPoint(helixPoints2, helixEndPoint2);
        thetaX = Theta(helixEndPoint1, helixMidPoint1, 2, 1) - Theta(helixEndPoint2, helixMidPoint1, 2, 1);
        RotateX(Input2, helixMidPoint1, thetaX);
        
        Input2Output();
//        TestOutput(helixMidPoint1, helixMidPoint2, helixPoints1, helixPoints2, helixEndPoint1, helixEndPoint2);
    }
    
    // This section identifies and extracts coords for the first helix in the provided file.
    private double[][] HelixSetup(String[] helixInput){
        double[][] helixPoints = null;
        String helixChainID;        
        int initSeqNum;
        int endSeqNum;
        int length;
        boolean helixFound = false;
        
        for (int i=0; i<helixInput.length-1; i++){
            if ("HELIX ".equals(RecordType(helixInput[i]))){
                helixChainID = HelixChainID(helixInput[i]);                
                initSeqNum = HelixInitSeqNum(helixInput[i]);
                endSeqNum = HelixEndSeqNum(helixInput[i]);                
                length = HelixLength(helixInput[i]);
                helixPoints = new double[length][3];
                HelixCoordExtract(helixInput, helixPoints, helixChainID, initSeqNum, endSeqNum);
                helixFound = true;
            }
            if (helixFound){
                break;
            }
        }
        return helixPoints;
    }
    
    // This section extracts the coords of the CA atoms of the helix to a seperate matrix.
    private void HelixCoordExtract(String[] helixInput, double[][] coords, String helixChainID, int initSeqNum, int endSeqNum){
        int j = 0;
        String chainID;
        int resSeq;
        
        for (int i=0; i<helixInput.length-1; i++){
            if ("ATOM  ".equals(RecordType(helixInput[i]))){
                chainID = ChainID(helixInput[i]);
                if (chainID.equals(helixChainID)){
                    resSeq = ResSeq(helixInput[i]);                    
                    if (resSeq >= initSeqNum && resSeq <= endSeqNum){
                        if (" CA ".equals(AtomName(helixInput[i]))){
                            coords[j][0] = XCoord(helixInput[i]);
                            coords[j][1] = YCoord(helixInput[i]);
                            coords[j][2] = ZCoord(helixInput[i]);
                            j++;
                        }
                    }                    
                    if (resSeq > endSeqNum){
                        break;
                    } 
                }
            }
        }
    }
    
    private void HelixMidPoint(double[][] helixPoints, double[] helixMidPoint){
        int midpoint, start, stop;
        midpoint = helixPoints.length;
        midpoint = midpoint/2;
        start = midpoint - 2;
        stop = start + 4;
        for (int i=0; i<3; i++){
            helixMidPoint[i] = CoordAvg(helixPoints, start, stop, i);
        }
    }
    
    private void MoveDistance(double[] midPoint1, double[] midPoint2, double[] moveDist){
        for (int i=0; i<3; i++){
            moveDist[i] = midPoint1[i] - midPoint2[i];
        }
    }
    
    private void HelixEndPoint(double[][] helixPoints, double[] helixEndPoint){
        int start, stop;
        stop = helixPoints.length;
        start = stop - 4;
        for (int i=0; i<3; i++){
            helixEndPoint[i] = CoordAvg(helixPoints, start, stop, i);
        }
    }

    private void MoveInput(String[] helixInput, double[] helixMoveDist){
        double xCoordNew;
        double yCoordNew;
        double zCoordNew;
        String xCoord;
        String yCoord;
        String zCoord;
        StringBuilder newRecord;
            
        for (int i=0; i<helixInput.length-1; i++){
            if ("ATOM  ".equals(RecordType(helixInput[i]))){
                xCoordNew = XCoord(helixInput[i]) + helixMoveDist[0];
                yCoordNew = YCoord(helixInput[i]) + helixMoveDist[1];
                zCoordNew = ZCoord(helixInput[i]) + helixMoveDist[2];
                xCoord = String.format("%8.3f",xCoordNew);
                yCoord = String.format("%8.3f",yCoordNew);
                zCoord = String.format("%8.3f",zCoordNew);
                newRecord = new StringBuilder(helixInput[i]);
                newRecord.replace(30, 38, xCoord);
                newRecord.replace(38, 46, yCoord);
                newRecord.replace(46, 54, zCoord);
                helixInput[i] = newRecord.toString();
            }
        }
    }
    
    private void RotateZ(String[] helixInput, double[] helixMidPoint, double theta){
        double sinTheta = sin(theta);
        double cosTheta = cos(theta);
        double xCoordOrg;
        double yCoordOrg;
        double xCoordNew;
        double yCoordNew;
        String xCoord;
        String yCoord;
        StringBuilder newRecord;
            
        for (int i=0; i<helixInput.length-1; i++){
            if ("ATOM  ".equals(RecordType(helixInput[i]))){
                xCoordOrg = XCoord(helixInput[i]) - helixMidPoint[0];
                yCoordOrg = YCoord(helixInput[i]) - helixMidPoint[1];
                xCoordNew = ((xCoordOrg*cosTheta) - (yCoordOrg*sinTheta)) + helixMidPoint[0];
                yCoordNew = ((yCoordOrg*cosTheta) + (xCoordOrg*sinTheta)) + helixMidPoint[1];
                xCoord = String.format("%8.3f",xCoordNew);
                yCoord = String.format("%8.3f",yCoordNew);
                newRecord = new StringBuilder(helixInput[i]);
                newRecord.replace(30, 38, xCoord);
                newRecord.replace(38, 46, yCoord);
                helixInput[i] = newRecord.toString();
            }
        }
    }
    
    private void RotateY(String[] helixInput, double[] helixMidPoint, double theta){
        double sinTheta = sin(theta);
        double cosTheta = cos(theta);
        double xCoordOrg;
        double zCoordOrg;
        double xCoordNew;
        double zCoordNew;
        String xCoord;
        String zCoord;
        StringBuilder newRecord;
            
        for (int i=0; i<helixInput.length-1; i++){
            if ("ATOM  ".equals(RecordType(helixInput[i]))){
                xCoordOrg = XCoord(helixInput[i]) - helixMidPoint[0];
                zCoordOrg = ZCoord(helixInput[i]) - helixMidPoint[2];
                xCoordNew = ((xCoordOrg*cosTheta) - (zCoordOrg*sinTheta)) + helixMidPoint[0];
                zCoordNew = ((zCoordOrg*cosTheta) + (xCoordOrg*sinTheta)) + helixMidPoint[2];
                xCoord = String.format("%8.3f",xCoordNew);
                zCoord = String.format("%8.3f",zCoordNew);
                newRecord = new StringBuilder(helixInput[i]);
                newRecord.replace(30, 38, xCoord);
                newRecord.replace(46, 54, zCoord);
                helixInput[i] = newRecord.toString();
            }
        }
    }
    
    private void RotateX(String[] helixInput, double[] helixMidPoint, double theta){
        double sinTheta = sin(theta);
        double cosTheta = cos(theta);
        double yCoordOrg;
        double zCoordOrg;        
        double yCoordNew;
        double zCoordNew;
        String yCoord;
        String zCoord;
        StringBuilder newRecord;
            
        for (int i=0; i<helixInput.length-1; i++){
            if ("ATOM  ".equals(RecordType(helixInput[i]))){
                yCoordOrg = YCoord(helixInput[i]) - helixMidPoint[1];
                zCoordOrg = ZCoord(helixInput[i]) - helixMidPoint[2];
                yCoordNew = ((yCoordOrg*cosTheta) - (zCoordOrg*sinTheta)) + helixMidPoint[1];
                zCoordNew = ((zCoordOrg*cosTheta) + (yCoordOrg*sinTheta)) + helixMidPoint[2];
                yCoord = String.format("%8.3f",yCoordNew);
                zCoord = String.format("%8.3f",zCoordNew);
                newRecord = new StringBuilder(helixInput[i]);
                newRecord.replace(38, 46, yCoord);
                newRecord.replace(46, 54, zCoord);
                helixInput[i] = newRecord.toString();
            }
        }
    }
    
    private String RecordType(String record){
        String recordType = record.substring(0,6);
        return recordType;
    }
    
    private String AtomName(String record){
        String atomName = record.substring(12,16);
        return atomName;
    }    
    
    private String HelixChainID(String record){
        String chainID = record.substring(19, 20);
        return chainID;
    }
    
    private String SheetChainID(String record){
        String chainID = record.substring(21, 22);
        return chainID;
    }
    
    private String ChainID(String record){
        String chainID = record.substring(21, 22);
        return chainID;
    }
    
    private int HelixInitSeqNum(String record){
        int initSeqNum;
        String initSeqNumStr = record.substring(21, 25).replace(" ", "");
        initSeqNum = Integer.parseInt(initSeqNumStr);
        return initSeqNum;
    }
    
    private int HelixEndSeqNum(String record){
        int endSeqNum;
        String endSeqNumStr = record.substring(33, 37).replace(" ", "");
        endSeqNum = Integer.parseInt(endSeqNumStr);
        return endSeqNum;
    }
    
    private int SheetInitSeqNum(String record){
        int initSeqNum;
        String initSeqNumStr = record.substring(22, 26).replace(" ", "");
        initSeqNum = Integer.parseInt(initSeqNumStr);
        return initSeqNum;
    }
    
    private int SheetEndSeqNum(String record){
        int endSeqNum;
        String endSeqNumStr = record.substring(33, 37).replace(" ", "");
        endSeqNum = Integer.parseInt(endSeqNumStr);
        return endSeqNum;
    }
    
    private int ResSeq(String record){
        int resSeq;
        String resSeqStr = record.substring(22, 26).replace(" ", "");
        resSeq = Integer.parseInt(resSeqStr);
        return resSeq;
    }
    
    private int HelixLength(String record){
        int length;
        String lengthStr = record.substring(71, 76).replace(" ", "");
        length = Integer.parseInt(lengthStr);
        return length;
    }
    
    private double AvgX(String[] record, int numRec){
        double avgX = 0;
        int j = numRec;
        for (int i=0; i < numRec; i++){
            avgX = avgX + XCoord(record[i]);
        }
        avgX = avgX/j;
        return avgX;
    }
    
    private double AvgY(String[] record, int numRec){
        double avgY = 0;
        int j = numRec;
        for (int i=0; i < numRec; i++){
            avgY = avgY + YCoord(record[i]);
        }
        avgY = avgY/j;
        return avgY;
    }
    
    private double AvgZ(String[] record, int numRec){
        double avgZ = 0;
        int j = numRec;
        for (int i=0; i < numRec; i++){
            avgZ = avgZ + ZCoord(record[i]);
        }
        avgZ = avgZ/j;
        return avgZ;
    }
        
    private double XCoord(String record){
        double xCoord;
        String xCoordStr = record.substring(30, 38).replace(" ", "");
        xCoord = Double.parseDouble(xCoordStr);
        return xCoord;
    }
    
    private double YCoord(String record){
        double yCoord;
        String yCoordStr = record.substring(38, 46).replace(" ", "");
        yCoord = Double.parseDouble(yCoordStr);
        return yCoord;
    }
    
    private double ZCoord(String record){
        double zCoord;
        String zCoordStr = record.substring(46, 54).replace(" ", "");
        zCoord = Double.parseDouble(zCoordStr);
        return zCoord;
    }
    
    private double CoordAvg(double[][] helixPoints, int start, int stop, int coordPosition){
        double coordAvg = 0;
        int divisor = stop - start;
        for (int i=start; i < stop; i++){
            coordAvg = coordAvg + helixPoints[i][coordPosition];            
        }
        coordAvg = coordAvg/divisor;
        return coordAvg;
    }
    
    private double Theta(double[] helixMidPoint, double[] helixEndPoint, int opp, int adj){
        double theta = atan((helixEndPoint[opp] - helixMidPoint[opp]) / (helixEndPoint[adj] - helixMidPoint[adj]));
        return theta;
    }
    
    private void Output(String record, double x, double y, double z){
        String xCoord;
        xCoord = String.format("%8.3f",x);
        String yCoord;
        yCoord = String.format("%8.3f",y);
        String zCoord;
        zCoord = String.format("%8.3f",z);
        StringBuilder newRecord = new StringBuilder(record);
        newRecord.replace(12, 16, "  S ");
        newRecord.replace(17, 20, "   ");
        newRecord.replace(30, 38, xCoord);
        newRecord.replace(38, 46, yCoord);
        newRecord.replace(46, 54, zCoord);
        OutputTextArea.append(newRecord + "\n");
    }
    
    private void Input2Output(){
        OutputTextArea.setText("");
        for(int i=0; i<Input2.length; i++){
            OutputTextArea.append(Input2[i] + "\n");
        }        
    }
    
    private void TestOutput(double[] helixMidPoint1, double[] helixMidPoint2, double[][] helixPoints1, double[][] helixPoints2, double[] helixEndPoint1, double[] helixEndPoint2){
        InputTextArea.setText("");
        for(int i=0; i<helixPoints1.length; i++){
            for (int j=0; j<3; j++){
                InputTextArea.append(helixPoints1[i][j] + ", ");
            }
            InputTextArea.append("\n");
        }
        InputTextArea.append("\n");
        for(int i=0; i<helixPoints2.length; i++){
            for (int j=0; j<3; j++){
                InputTextArea.append(helixPoints2[i][j] + ", ");
            }
            InputTextArea.append("\n");
        }
        InputTextArea.append("\n");
        InputTextArea.append("Midpoint 1: ");
        for (int i=0; i<3; i++){
            InputTextArea.append(helixMidPoint1[i] + ", ");
        }
        InputTextArea.append("\n");
        InputTextArea.append("Midpoint 2: ");
        for (int i=0; i<3; i++){
            InputTextArea.append(helixMidPoint2[i] + ", ");
        }
        InputTextArea.append("\n");
        InputTextArea.append("Endpoint 1: ");
        for (int i=0; i<3; i++){
            InputTextArea.append(helixEndPoint1[i] + ", ");
        }
        InputTextArea.append("\n");
        InputTextArea.append("Endpoint 2: ");
        for (int i=0; i<3; i++){
            InputTextArea.append(helixEndPoint2[i] + ", ");
        }
        InputTextArea.append("\n");
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Interface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Interface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Interface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Interface.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new Interface().setVisible(true);
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton AlignHelices;
    private javax.swing.JMenuItem Exit;
    private javax.swing.JFileChooser FileChooser;
    private javax.swing.JButton Helix1;
    private javax.swing.JButton Helix2;
    private javax.swing.JButton HelixCenter;
    private javax.swing.JLabel InputLabel;
    private javax.swing.JTextArea InputTextArea;
    private javax.swing.JMenuItem Open;
    private javax.swing.JLabel OutputLabel;
    private javax.swing.JTextArea OutputTextArea;
    private javax.swing.JButton bSheetCenter;
    private javax.swing.JButton caExtract;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    // End of variables declaration//GEN-END:variables

    // Global Variables
    public String[] Input;
    public String[] Input2;
}
